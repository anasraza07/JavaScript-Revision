Scopes help us avoid naming conflicts
Any varibale we create inside curly brackets will only exist inside the curly brackets

Strategy for Javascript:

1. Figure out what steps we need
2. Convert these steps into code
   and this is called Algorithm

Falsy values:
false, 0, "", null, undefined, Nan
except above list all are truthy values
Nan: when we do some invalid math
If the first value is falsy the guard operator <&&> will stop early and the result will be the first value, otherwise it wont stop early and give us a second value as a result
In default operator <||> it will stop early when first value is truthy; it is to set the default value.
&& has a higher priority than || operator

ChaiAurCode:
******************** Variables ********************
Prefer not to use 'var' because of issue in block scope and functional scope
kisi keyword ke bagair bhi variable bn skta hai (accountCity = "Jaipur"), memory reserve hoskti hai but krna nhi hai aesa kbhi

******************** Datatypes ********************
number => 2 to the power 53
bigint
string => ""
boolean => true/false
null => standalone value
undefined => undefined value
symbol => unique

object
type of null is object
type of undefined is undefined

"33" => 33
"33abc" => Nan
true => 1; false/null => 0

1 => true; 0 => false
"" => false
"anas" => true

******************** Operations ********************
"1" + 2 => 12
1 + "2" => 12
"1" + 2 + 2 => 122
1 + 2 + "2" => 32

******************** Summary ********************
Primitive Datatype (call by value)
7 types: String, Number, Boolean, null, undefined, Symbol, BigInt

Non-primitive Datatype (call by reference)
Array, Objects, Functions

typeof string => string
typeof number => number
typeof boolean => boolean
typeof null => object
typeof undefined => undefined
typeof symbol => symbol
typeof array => object
typeof object => object
typeof function => object function

string.length
string.toUpperCase()
string.charAt(2)
string.indexOf('t')
string.subString(2, 4) => index 2 se shuru index 4 tk (index 4 not included)
string.slice(-3, 4) => index (length + (-3)) se shuru index 4 tk (not included)
string.trim()
string.replace('searchValue', 'replaceValue')
string.split('seperator')

number.toString().length
number.toFixed(0)
number.toPrecision(4) => decimal ko precise krke dega 4 digit hi hamesha
number.toLocaleString('en-IN') => by default according to UAE standard main commas lagaake dega

Math.abs(-4) => 4 (make any negative number positive);
Math.round(4.6);
Math.ceil(4.2);
Math.floor(4.9);
Math.min(4, 3, 6, 8);
Math.max(4, 3, 6, 8);
Math.random();
(Math.random() * 10) + 1
imp trick =  (Math.floor(Math.random() * (max - min + 1)) + min)

******************** Dates ********************
new Date().toString() => Wed Mar 01 2023 12:43:12 GMT+0000 (Coordinated Universal Time)
new Date().toDateString() => Wed Mar 01 2023
new Date().toLocaleString() => 3/1/2023, 12:43:12 PM
new Date(2023, 0, 23).toDateString() => Mon Jan 23 2023
new Date(2023, 0, 23, 5, 3).toLocaleString() => Mon Jan 23 2023 05:03:00 AM
new Date("2023-01-14").toLocaleString() => 1/14/2023, 12:00:00 AM
new Date("01-14-2023").toLocaleString() => 1/14/2023, 12:00:00 AM
Date.now() => miliseconds from 01 Jan 1970
new Date("01-14-2023").getTime() => date into miliseconds
miliseconds into seconds => miliseconds / 1000
new Date().getMonth() + 1 => start from (0)
new Date().getDay() => start from sunday (0) 
new Date().toLocaleSring('default', { weekend: long }) => we can customize more

******************** Control Flow ********************
if(balance > 500) console.log('test') => implicit scope (not a best practice)
comparison operators:
<, >, <=, >=, ==, !=, ===, !==

logical operators => &&, ||

switch case => agr break use nhi kia to jahan case match kr jayega wahan se saara code execute hoga except default case

extra falsy values for interview => -0, BigInt 0n
surprised truthy values => "0", 'false', [], {}, 

to check empty array we should check like this:
if (array.length === 0) { console.log("Array is empty") };

to check empty object we should check like this:
if (Object.keys(obj).length === 0) { console.log("Object is empty") };

Nullish Coalescing Operator (??): null undefined 
returns its right-hand side operand when its left-hand side operand is null or undefined, otherwise returns its left-hand side operand.
val1 = 5 ?? 10 // output => 5
val1 = null ?? 10 // output => 10
val1 = undefined ?? 20 // output => 20
val1 = null ?? 10 ?? 29 // output => 10

Ternary Operator:
condition ? true : false

******************** Functions ********************
sayMyName => reference
sayMyName() => execution

default value to function parameter = agr argument pass nhi kia to wo default value use hojayegi
function default(num1 = 2){};

rest operator => extra function arguments ko eik array main pack krke de dega
function restFunction(...num1){ return num1 };
restFunction(200, 3000, 399, 299) => [200, 3000, 399, 299]

closures: child function ka parent function ke variable ko access krna

this = current context, current values, current variables ki baat krta hai object scope ke andr agr ho to wrna function main aesa kch nhi deta
browser ke andr jo global object hai wo hai window object 
node ke andr this ko console.log krne se empty object aata hai but agr function ke andr this ko console.log kia to bht si values aati hain
arrow function main this empty object hi deta hai

arrow function use krte hue curly brackets main return use hoga but agr parentheses hain to return use nhi hoga
implicit return = const addOne = (num1, num2) => num1 + num2

object return krne ke liye parentheses use krne hi parenge
implicit return = const addOne = (num1, num2) => ({username: 'Anas'})

IIFE: global scope ke pollution se bachne ke liye aur immediately function ko invoke krne ke liye use hota hai
IIFE ko end krne ke liye semicolon lagana bhi zaroori hai

******************** Arrays ********************
shallow copies = copy with references (original bhi change hota rahega)
deep copies = without reference

Array methods:
push
pop
unshift
shift
includes
indexOf
join
slice() = original array ko manipulate nhi krta
splice() = original array ko manipulate krta hai aur range bhi included hoti hai
concat() = combine two or more arrays and returns a new array
spread operator = same concat wala kaam bhi ye krta hai easily
flat(Infinity) = arrays ke andr arrays sb elements ko eik hi array main krdega

Array.isArray('Anas') => false
Array.from('Anas') => ['A', 'n', 'a', 's']
const allHeros = [...marvelHeros, ...dcHeros]
Array.of(var1, var2, var3) => [var1_value, var2_value, var3_value]

High Order Array Loops:
Map bhi eik iterator hai object ki tarh bs ye key value pair ki sequence yaad rkhta hai and kisi same chz ko repeat nhi hone deta aur forOf loop main bhi use hojaata hai jbke obj use nhi ho paata
const map = new Map();
map.set('In', 'India')
map.set('PK', 'Pakistan')

for (const key of map){
   console.log(key) => [In, India], [PK, Pakistan]
}
for (const [key, value] of map){
   console.log(key, ':-', value) => [In :- India], [PK :- Pakistan]
}

forof 'values' deta hai jbke forin 'keys' deta hai
array ki bhi keys hoti hain jo 0 se start hoti hain aur sb numbers hoti hain
forin = objects ke saath use hojaata hai easily but map ke saath kaam nhi krta

.forEach((item, index, array) => {});

.reduce((accumulator, currentValue) => {}); = ye do paramters leta hai eik accumulator aur doosra currentValue aur phr callback ke baad initial value bhi deni hoti hai jo first time accumulator leta hai and then uske baad se (accumulator + currentValue) jo result aata hai wo accumulator ki value ban jaati hai


07-Functions
a function lets us to reuse code and make our code easier to update
rules for function name:

1. cant use special words ex. function
2. cant start with a number
3. cant use special characters except $ and \_
   best practice = use camelCase
   Return statement: let us get a value out of a function
   Parameter: put value into a function

08-Objects
objects let us group and use multiple values together
obj.notExist = undefined
Bracket notation lets us use properties that dont work with dot notation
Function inside object = Method ex. log is a method inside console which is an object
Built-in objects: Objects provided by the language itself

1. JSON Object: help us work with json, now what is json?
   JSON (Javascript object notation): is basically a syntax similar to JS object, it is universal as it can understand by almost all programming languages while Javascript object only make sense in Javascript that's why we use JSON when we send data between computers. We also use JSON when we store data.
   JSON Object is used to convert back and forth between Javascript object and JSON
2. Localstorage: used to save values more permanently and doesnt delete the values when we refresh the page while varibales are temporary and after refresh the page they are set to the default values again.
   Localstorage only supports strings
   null and undefined are both similar things but null = when we intentionally want something to be empty. In most cases they both work in the same way
   Other values like strings can also have properties and methods
   So Javascript automatically wraps string in a special object and this feature is called Auto-Boxing. This feature also work with other type of values like numbers and booleans.
   but it not works with null and undefined it wil give us an error.
   Objects are references, the values inside the object save somewhere in computer's memory and the varibale actually just get the reference to that object so by this way Javascript become more efficient when used to copy object so Javascript just makes copy of the reference to that object which is much faster tha copying a whole big object over and over again, this called Copy by Reference.
   so we are able to change value inside the object even though we use const but bcuz it has the reference so const doesnt prevent us from reaching into the reference and changing the object
   We can't compare objects directly even the values are same bcuz code compares the reference we are saving and not the values inside the object
   Destructuring: its an easier way to take properties out of an object

09-DOM
DOM is an another Built-in object called document object, the document object represents / models the webpage thats why is called document object model
We can have elements inside Javascript, the DOM combines Javascript and html together and gives Javascript full control of the webpage.
When an HTML element is inside our Javascript it converted into a Javascript object
innerText will give us the text inside the element wihtout all those spaces around it.
cLicks, keydowns => events
onclick, onkeydown => event listeners
Every event listener also gets an event object.
When string only contains a number and we subract, divide or multiply Javascript will automatically convert string into a number.
but adding works differently it will change number into a string and combines them both string and a number thats why the best practice is always always do math using nummbers.
Window is also a Built-in object that represents a browser. what is inside the browser is inside this window object. it has a shortcut that we dont have to put window name again and again Javascript adds it automatically for us before any property of window object

10-HTML, CSS and Javascript together
Every element has another property called classlist that gives us control of the class attribute, classList itselt is an object also which has some properties and methods
rel attribute in link element tells the computer what type of file we are loading

11-Arrays and Loops (PART 1):
An array is an another type of value in Javascript and it represents a list of other values
Index: represents the position in array that we want to get, index starting from zero (0) called a 0 indexed array.
Array is an object but it is just a special type of object.
Loops let us run some code over and over, there are 3 major parts of loop:
a. loop varibale
b. loop condition
c. increment step
Each time we run a loop, this is called iteration
For vs While loop:
standard loop => for
non-Standard loop => while
Accumulator Pattern:

1. create a variable to store the result
2. loop through the array and update the result

(PART 2):
Arrays works the same way they are references also, if we create a variable of an array the variable doesnt actually contain values rather than that array is saved somewhere in computers memory and this variable only contains a reference that points to where this array is. This means if we create a copy of this variable, array2 doesnt contain a copy of the values, it just contains a copy of the reference. So now both of the varibales are pointing to the same array.
More features about loops => 1. break = exit a loop early (let us stop the loop early) 2. continue = lets us skip 1 iteration of the loop

12-Advanced Functions
Functions are also values, we can save them inside a variable
Passing a function into another function, called : callback function or Callback.
SetTimeout() allows us to run function in the future.
Asynchronous code: means computer wont wait for a line to finish before going to the next line, so for SetTimeout it will just set up the timer and then immediately go to the next line.
Synchronous code: means computer will wait for one line to finish before going to the next line.
all the code that we normally write will be synchronous code, the only time that code becomes asynchronous is when we use certain features of Javascript like SetTimeout.
Advantages of SetTimeout: it doesnt block our code for x seconds, it just sets up the timer in the background and go to the next line of code
SetInterval() it will keep running function in the future. SetInterval returns a number which is like an ID so that can use this ID to stop the interval.
.forEach is the prefer   way to loop through an array, in forEach return keyword works like continue in forloop for skip any iteration, but there is not the easy way to use break in forEach so if we need to use break then its better to use regualar forLoop.

(PART 2):
When passing a function into another function it is perfer to use an arrow function, arrow function works mostly like regular function but it have some shortcuts that regular dont have
Arrow function doesnt provide us hoisting which means we cant call it before we create it like regular function so for hoisting regular function must be use
Every HTML element have a method that is addEventListener which lets us run some code when we interact with the element (it sort of does something as onclick)
The way to find these event names is to look at this attribute, so the word after "on" is the event
addEventListener has some Advantages over an attribute:

1. it lets us add multiple event listeners for one event
2. we can remove an event listener using the another method .removeEventListener
   that's why Best practice = use addEventListener instead of using onclick attribute
   2 More Array Methods: (i)- .filter() is just like forEach but only the difference is that in .filter() the inner function will return a value.
   .filter() creates a new array, if inner function return true it puts the value in an array, if the inner function return false it will not put the value in the new array.
   (ii)- .map() is just like forEach and filter(), but it transform an array into another array
   .map() creates a new array, and then whatever we return will be added to new array.
   Closure: means if a function has access to a value, it will always have access to that value. The value gets packaged together (enclosed) with the function
